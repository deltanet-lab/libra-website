---
id: storage
title: 存储
custom_edit_url: https://github.com/deltanet-lab/libra-website-cn/edit/master/docs/crates/storage.md
---


The storage module provides reliable and efficient persistent storage for the
entire set of data on the Libra Blockchain, as well as the necessary data used
internally by Libra Core.

存储模块为Libra区块链上的全部数据以及Libra Core内部使用的必要数据提供可靠、高效的持久存储。

## 概览

The storage module is designed to serve two primary purposes:

1. Persist the blockchain data, specifically the transactions and their outputs
   that have been agreed by validators via consensus protocol.
2. Provide a response with Merkle proofs to any query that asks for a part of the
   blockchain data. A client can easily verify the integrity of the response if
   they have obtained the correct root hash.

The Libra Blockchain can be viewed as a Merkle tree consisting of the following
components:

存储模块旨在满足两个主要目的：

1. 保存区块链数据，特别是验证者通过共识协议达成的交易及其输出。
2. 对要求部分区块链数据的任何查询提供带有Merkle证明的响应，如果客户端已获得正确的根哈希，则可以轻松地验证响应的完整性。

Libra区块链可以看作是由以下组件组成的Merkle树：

![data](https://developers.libra.org/docs/assets/data.png)


### 账本历史记录

Ledger history is represented by a Merkle accumulator. Each time a transaction
`T` is added to the blockchain, a *TransactionInfo* structure containing the
transaction `T`, the root hash for the state Merkle tree after the execution of
`T` and the root hash for the event Merkle tree generated by `T` is appended to
the accumulator.

账本历史记录由Merkle累加器表示。每次交易`T`被添加到区块链，（i）事务`T`的哈希，（ii）执行`T`之后的状态Merkle树的根哈希，（iii）以及由`T`生成的事件Merkle树的根哈希，将被包含在一个*TransactionInfo*结构中并将被附加到累加器。

### 账本状态

The ledger state at each version is represented by a sparse Merkle tree that has the
state of all accounts. The keys are the 256-bit hash of the addresses, and their
corresponding value is the state of the entire account serialized as a binary
blob. While a tree of size `2^256` is an intractable representation, subtrees
consisting entirely of empty nodes are replaced with a placeholder value, and
subtrees consisting of exactly one leaf are replaced with a single node.

每个版本的账本状态由具有所有帐户状态的稀疏Merkle树表示。键是地址的256位哈希，它们的对应值是序列化为二进制Blob的整个帐户的状态。因为一棵大小为`2^256`的树是很难处理的表示形式，所以完全由空节点组成的子树将被替换为占位符，而仅由一个叶子组成的子树将被替换为单个节点。

While each *TransactionInfo* structure points to a different state tree, the new
tree can reuse unchanged portion of the previous tree, forming a persistent data
structure.

虽然每个*TransactionInfo*结构指向不同的状态树，但新的树可以重用前一棵树的未更改部分，从而形成持久数据结构体。


### 事件

Each transaction emits a list of events and those events form a Merkle accumulator.
Similar to the state Merkle tree, the root hash of the event accumulator of a
transaction is recorded in the corresponding *TransactionInfo* structure.

每个事务发出一个事件列表，这些事件形成一个Merkle累加器。与状态Merkle树类似，一个事务的事件累加器的根哈希记录在相应的*TransactionInfo*结构中。

### 账本信息与签名

A *LedgerInfo* structure that has the root hash of the ledger history
accumulator at some version and other metadata is a binding commitment to
the ledger history up to this version. Validators sign the corresponding
*LedgerInfo* structure every time they agree on a set of transactions and their
execution outcome. For each *LedgerInfo* structure that is stored, a set of
signatures on this structure from validators are also stored, so
clients can verify the structure if they have obtained the public key of each
validator.

具有某些版本的账本历史记录累加器的根哈希值和其他元数据的*LedgerInfo*结构是对直到该版本的账本历史记录的绑定承诺。 每当验证器们对一组事务及其执行结果达成一致时，验证器便会签名相应的*LedgerInfo*结构。对于存储的每个*LedgerInfo*结构，还将存储验证器在该结构上的一组签名，如果客户端已获得每个验证器的公钥，就可以验证该结构。

## 实现细节（Implementation Details）

The storage module uses [RocksDB](https://rocksdb.org/) as its physical storage
engine. Since the storage module needs to store multiple types of data, and
key-value pairs in RocksDB are byte arrays, there is a wrapper on top of RocksDB
to deal with the serialization of keys and values. This wrapper enforces that all data in and
out of the DB is structured according to predefined schemas.

存储模块使用[RocksDB](https://rocksdb.org/)作为其物理存储引擎。由于存储模块需要存储多种类型的数据，并且RocksDB中的键值对是字节数组，因此RocksDB上有一个处理键值序列化的包装器。该包装器会根据预定义的格式来构造进出数据库的所有数据。

The core module that implements the main functionalities is called *LibraDB*.
While we use a single RocksDB instance to store the entire set of data, related
data are grouped into logical stores &mdash; for example, ledger store, state store,
and transaction store, etc.

实现主要功能的核心模块称为*LibraDB*。虽然我们使用单个RocksDB实例存储整个数据集，但相关数据被分组为几个逻辑存储 - 例如，账本存储，状态存储和事务存储等。

For the sparse Merkle tree that represents ledger state, we optimize the disk
layout by using branch nodes with 16 children that represents 4-level subtrees
and extension nodes that represents a path without branches. However, we still
simulate a binary tree when computing the root hash and proofs. This modification
results in proofs that are shorter than the ones generated by Ethereum's Merkle
Patricia tree.

对于表示账本状态的稀疏Merkle树，我们通过使用具有16个子代的分支节点（代表4级子树）和扩展节点（不带分支的路径）来优化磁盘布局。但是，我们在计算根哈希和证明时仍会模拟一个二叉树。这种修改产生的证明比以太坊的Merkle Patricia树生成的证明短。

## 模块的代码组织
```
    storage
          └── accumulator      # Implementation of Merkle accumulator.
          └── libradb          # Implementation of LibraDB.
          └── schemadb         # Schematized wrapper on top of RocksDB.
          └── scratchpad       # In-memory representation of Libra core data structures used by execution.
          └── jellyfish_merkle # Implementation of sparse Merkle tree.
          └── state_view       # An abstraction layer representing a snapshot of state where the Move VM reads data.
          └── storage_client   # A Rust wrapper on top of GRPC clients.
          └── storage_proto    # All interfaces provided by the storage module.
          └── storage_service  # Storage module as a GRPC service.
```

